const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

// Helper to run shell commands
function run(command) {
    try {
        console.log(`Running: ${command}`);
        execSync(command, { stdio: 'inherit' });
    } catch (e) {
        console.error(`Command failed: ${command}`);
        process.exit(1);
    }
}

// Helper to ensure directory exists
function ensureDir(filePath) {
    const dirname = path.dirname(filePath);
    if (!fs.existsSync(dirname)) {
        fs.mkdirSync(dirname, { recursive: true });
    }
}

// Main function to simulate Micro-Commit & PR workflow
function microCommit({ branch, type, message, description, files, pushToRemote = false }) {
    // 1. Create Branch
    const branchName = branch || `feat/${Date.now()}`;
    // Check if branch exists
    try {
        run(`git checkout -b ${branchName}`);
    } catch (e) {
        // If branch exists, just checkout
        run(`git checkout ${branchName}`);
    }

    // 2. Apply Changes
    if (files && files.length > 0) {
        files.forEach(f => {
            const absolutePath = path.resolve(process.cwd(), f.path);
            ensureDir(absolutePath);
            fs.writeFileSync(absolutePath, f.content);
            console.log(`Wrote/Updated file: ${f.path}`);
        });
    }

    // 3. Commit
    run('git add .');
    try {
        run(`git commit -m "${type}: ${message}" -m "${description || ''}"`);
    } catch (e) {
        console.log("Nothing to commit, skipping...");
        run('git checkout main');
        return;
    }

    // 4. Mimic PR & Merge
    run('git checkout main');
    // --no-ff creates a merge commit, simulating a PR merge
    const prNumber = Math.floor(Math.random() * 1000) + 1;
    const prTitle = `Merge pull request #${prNumber} from ${branchName}`;
    const prDesc = `PR Description:\n${description || message}\n\nAuto-generated by automation script.`;

    run(`git merge --no-ff ${branchName} -m "${prTitle}" -m "${prDesc}"`);

    // 5. Push to remote (Optional, can be batched)
    if (pushToRemote) {
        try {
            run('git push origin main');
        } catch (e) {
            console.warn("Failed to push to remote. Ensure remote is configured.");
        }
    }
}

// Processing
if (require.main === module) {
    const args = process.argv.slice(2);
    if (args.length > 0) {
        try {
            const input = JSON.parse(args[0]);
            // Support both single object and array of objects
            const operations = Array.isArray(input) ? input : [input];

            operations.forEach(op => {
                console.log(`Processing operation: ${op.message}`);
                microCommit(op);
            });

        } catch (e) {
            console.error("Failed to parse arguments:", e);
        }
    }
}

module.exports = { microCommit };
